// Copyright 2021 The Mellium Contributors.
// Use of this source code is governed by the BSD 2-clause
// license that can be found in the LICENSE file.

// The genxmltag command creates marshalers for struct types.
package main // import "mellium.im/xmpp/internal/genxmltag"

import (
	"bytes"
	"flag"
	"go/format"
	"io"
	"log"
	"os"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

const tmpl = `// Code generated by "genxmltag{{if gt (len .Args) 0}} {{end}}{{.Args}}"; DO NOT EDIT.

package {{.Pkg}}

import (
	"encoding/xml"
)


// TokenReader implements xmlstream.Marshaler.
func ({{.Receiver}}) TokenReader() xml.TokenReader {
	panic("not yet implemented")
}

// WriteXML satisfies the xmlstream.WriterTo interface.
// It is like MarshalXML except it writes tokens to w.
func ({{.Receiver}}) WriteXML(w xmlstream.TokenWriter) (n int, err error) {
	return xmlstream.Copy(w, {{.Receiver | recvVar}}.TokenReader())
}

// MarshalXML implements xml.Marshaler.
func ({{.Receiver}}) MarshalXML(e *xml.Encoder, _ xml.StartElement) error {
	_, err := {{.Receiver | recvVar}}.WriteXML(e)
	return err
}`

func main() {
	log.SetFlags(0)
	log.SetPrefix("genxmltag: ")
	var (
		outFile = "marshal.go"
		typ     = ""
	)

	flag.StringVar(&outFile, "filename", outFile, "filename to generate")
	flag.StringVar(&typ, "type", typ, "comma-separated list of type names; must be set")
	flag.Parse()

	types := strings.Split(typ, ",")
	if len(types) == 0 {
		log.Fatal("must specify at least one type")
	}

	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.LoadSyntax,
	}, ".")
	if err != nil {
		log.Fatalf("error loading package: %v", err)
	}
	pkg := pkgs[0]

	for _, typ := range pkg.TypesInfo.Defs {
		for specified := range types {
			if typ != nil && typ.Name() == specified {
				panic("TODO: generate")
			}
		}
	}

	parsedTmpl, err := template.New("out").Funcs(template.FuncMap{
		"recvVar": func(s string) string {
			idx := strings.IndexByte(s, ' ')
			if idx == -1 {
				idx = 0
			}
			return s[:idx]
		},
	}).Parse(tmpl)
	if err != nil {
		log.Fatalf("error parsing template: %v", err)
	}

	var buf bytes.Buffer
	fd, err := os.Create(outFile)
	if err != nil {
		log.Fatalf("error creatng file %q: %v", outFile, err)
	}
	err = parsedTmpl.Execute(&buf, struct {
		Args      string
		Pkg       string
		Receivers []string
	}{
		Args: strings.Join(os.Args[1:], " "),
		Pkg:  pkg.Name,
		//Receivers: receivers,
	})
	if err != nil {
		log.Fatalf("error executing template: %v", err)
	}

	fmtBuf, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("error formatting source: %v", err)
	}

	_, err = io.Copy(fd, bytes.NewReader(fmtBuf))
	if err != nil {
		log.Fatalf("error writing file: %v", err)
	}
}
