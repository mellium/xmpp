// Copyright 2021 The Mellium Contributors.
// Use of this source code is governed by the BSD 2-clause
// license that can be found in the LICENSE file.

// The genfeature command creates default disco features for a package.
package main // import "mellium.im/xmpp/internal/genfeature"

import (
	"bytes"
	"flag"
	"go/format"
	"io"
	"log"
	"os"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

const tmpl = `// Code generated by "genfeature{{if gt (len .Args) 0}} {{end}}{{.Args}}"; DO NOT EDIT.

package {{.Pkg}}

import (
	"mellium.im/xmpp/disco/info"
)

// A list of service discovery features that are supported by this package.
var (
{{- range .Features }}
	{{.Name}} = info.Feature{Var: {{.Val}}}
{{- end }}
)

{{- if .Receiver }}
// ForFeatures implements info.FeatureIter.
func ({{.Receiver}}) ForFeatures(node string, f func(info.Feature) error) error {
	if node != "" {
		return nil
	}
	var err error
{{- range .Features }}
	err = f({{.Name}})
	if err != nil {
		return err
	}
{{- end }}
	return nil
}
{{- end }}`

type feature struct {
	Name string
	Val  string
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("genfeature: ")
	var (
		outFile  = "disco.go"
		vars     = `Feature:NS`
		receiver = ""
	)

	flag.StringVar(&outFile, "filename", outFile, "filename to generate")
	flag.StringVar(&vars, "vars", vars, "comma separated list of Name:Var pairs")
	flag.StringVar(&receiver, "receiver", receiver, "a method receiver for an info.FeatureIter implementation")
	flag.Parse()

	var features []feature
	for _, pair := range strings.Split(vars, ",") {
		vars := strings.Split(pair, ":")
		if len(vars) != 2 {
			log.Fatalf("invalid disco var pair: %q", pair)
		}
		features = append(features, feature{
			Name: vars[0],
			Val:  vars[1],
		})
	}

	pkgs, err := packages.Load(nil, ".")
	if err != nil {
		log.Fatalf("error loading package: %v", err)
	}
	pkg := pkgs[0]

	parsedTmpl, err := template.New("out").Parse(tmpl)
	if err != nil {
		log.Fatalf("error parsing template: %v", err)
	}

	var buf bytes.Buffer
	fd, err := os.Create(outFile)
	if err != nil {
		log.Fatalf("error creating file %q: %v", outFile, err)
	}
	err = parsedTmpl.Execute(&buf, struct {
		Args     string
		Pkg      string
		Receiver string
		Features []feature
	}{
		Args:     strings.Join(os.Args[1:], " "),
		Pkg:      pkg.Name,
		Receiver: receiver,
		Features: features,
	})
	if err != nil {
		log.Fatalf("error executing template: %v", err)
	}

	fmtBuf, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("error formatting source: %v", err)
	}

	_, err = io.Copy(fd, bytes.NewReader(fmtBuf))
	if err != nil {
		log.Fatalf("error writing file: %v", err)
	}
}
